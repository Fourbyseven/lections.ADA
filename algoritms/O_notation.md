Big O notation 

Это нотация для описания сложности алгоритма (исполььзуя подсчет количество операций)

O(1)
пример: алгоритмов занимающих O(1)
 
num = [1, 2, 3, 4, 5]

print(num[0])

dict_ = {'a':1, 'b':2, 'c':3}
print(dict_['a'])

ДЛЯ ДАННЫХ АЛГОРИТМОВ(ВЫВОД ЗНАЧЕНИЯ ПО ИНДЕКСУ ИЛИ КЛЮЧУ КОЛИЧЕСТВО ДЕЙТСИЙ ВСЕГДА БУДЕТ 1.  ДАЖЕ ЕСЛИ ЭЛЕММЕНТОВ
В СПИСКЕ СЛОВАРЕ БУДЕТ 1000)


O(n)
Если же мы хотим сделать обычный линейный поиск то сдесь количество операций зависит от 
количество элемментов в итерируемом обькте 

nums = [1, 2, 3, 4, 5]
target = 1

for i in nums:
    if i == target:
        return i


O(n2)
 

Чаще всего, это алгоритмы которые иттерирует обьект и внутри каждой итерации 
снова его иттерирует, Возьмем не самый лучший алгоритм поиска дубликатов в списке

nums = [1, 2, 3, 4, 5, 5]

def algoritm(nums):
    for i in range(len(nums)):
        num1 = nums[i]
        for j in range(len(nums)):
            num2 = nums[j]
            if i == j:
                continue # переходим к следующему num2 числу елси мы взяли одно и то же число для num1 и num2

            if num1 == num2:
                return True
    return False

algorithm(nums)

Со списком 6 элемментов наш алгоритм выполнит 30 операцийт в худщем случае если дубликатов нет,
у нас будет 100 элемментов топ операция будет 10000

O(log n)
Один самых быстрых алгоритмов. 


